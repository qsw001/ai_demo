I will implement the Hashlife algorithm in a new standalone JavaScript file `hashlife.js` (or integrated into `index.html` if preferred, but given the complexity, a separate logic module or clear section is better. Since the user asked for runnable code and the previous context was `index.html`, I will integrate it into `index.html` replacing the naive loop, but I'll plan carefully).

## 1. Core Data Structures (Quadtree DAG)
- **Node Class**:
  - `level`: Integer (0 for leaves, k for $2^k \times 2^k$ squares).
  - `nw, ne, sw, se`: References to child nodes (null for leaves).
  - `population`: Cached count of live cells (optional but useful).
  - `cache`: Memoization for the result of `nextGeneration`.
  - `id`: Unique identifier for hashing.

- **Hash Consing (Canonicalization)**:
  - A global `Map` or `Object` acting as the hash table.
  - Key: `${level},${nw.id},${ne.id},${sw.id},${se.id}`.
  - Value: The unique canonical Node instance.
  - `createNode(level, nw, ne, sw, se)`: Checks cache; returns existing or creates new.

## 2. Base Cases (Leaf Nodes)
- **Level 0**: Two canonical static nodes: `LIVE` (1) and `DEAD` (0).
- `createLeaf(alive)`: Returns one of the above.

## 3. Evolution Logic (The Recursive Step)
The core of Hashlife calculates the state of the *inner* $2^{k-1} \times 2^{k-1}$ square at $T + 2^{k-2}$ generations.

- **`node.nextGeneration()`**:
  - If cached, return it.
  - If level 2 (4x4 grid): Use brute force simulation (bit manipulation or lookup) to get the inner 2x2 at T+1.
  - If level > 2:
    - Construct 9 overlapping sub-squares from the 4 children.
    - Recursively call `nextGeneration` on these to get results at $T + 2^{k-3}$.
    - Combine these results and recurse again to get the final result at $T + 2^{k-2}$.
  - Cache and return the result.

## 4. Expansion & Coordinates
- **`expandUniverse(root)`**: Checks if the root has interesting activity near the boundary. If so, creates a new root at `level + 1` with the old root in the center and empty nodes surrounding it.
- **coordinate mapping**: Since the tree is relative, we need a way to inject patterns or draw the tree.
  - `setCell(x, y)`: Recursive traversal to find the leaf and rebuild the path (creating new nodes).

## 5. Integration Plan
1.  **Define the `Universe` class**: Manages the root node and the generation count.
2.  **Replace Game Loop**: Instead of `step()` modifying a grid, it will update the `root` reference.
3.  **Rendering**: A traversal function that draws the leaf nodes at the correct offsets. *Note: Hashlife is abstract; mapping it to the existing Canvas pan/zoom requires translating tree coordinates to world coordinates.*

## 6. Implementation Strategy
- I will first implement the core `Hashlife` logic (Node, HashConsing, Evolution) as a self-contained module within the `<script>`.
- Then, I will adapt the existing `index.html` UI to drive this new engine.
- **Note**: Hashlife jumps $2^{k-2}$ steps. For smooth animation, we might just step small amounts, or allow the user to jump huge amounts. The user asked for "algorithm optimization... deduce result after n generations". I will provide the ability to jump huge steps.

**Refinement**: The user specifically asked for "Runnable code... correct structure... output complete code". I will rewrite the script section of `index.html` to swap the naive array engine for Hashlife.

### Key Algo Details to Implement
- `construct(nw, ne, sw, se)`: The builder with hash consing.
- `getCenter(node)`: Returns the inner $2^{k-1}$ node (spatial only).
- `nextGeneration(node)`: Returns the result of advancing $2^{k-2}$ steps.
- **Horizontal/Vertical Forwarding**: Helper functions to combine quadrants.

### Execution Plan
1.  **Clear existing engine**: Remove `Uint8Array` logic.
2.  **Implement `CanonicalNode`**: The storage unit.
3.  **Implement `memoizedCalc`**: The recursive evolution.
4.  **Implement `draw`**: Recursive drawing of the quadtree.
5.  **Connect UI**: "Step" might now mean "Advance 1 gen" (slow in Hashlife without bit-hacks for low levels) or "Advance significant gens". I'll try to support single step by just asking for 2^0 evolution or similar, but Hashlife shines at large steps. I'll add a "Jump" button or modify the speed behavior.

*Self-Correction*: Pure Hashlife computes $2^{k-2}$ steps. To get exactly *n* steps (e.g., 1 step) is complex (binary decomposition of n). For this request ("deduce result after n generations"), I will ensure the core `advance(n)` logic is present using the standard binary decomposition method if needed, or just standard Hashlife exponential steps if acceptable. The prompt implies "deduce n generations", so `advance(node, generations)` is needed.

I will stick to the prompt's constraints: "Hashlife algorithm... complete runnable code".
