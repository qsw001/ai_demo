I will completely rewrite the JavaScript logic within `index.html` to provide a robust, runnable implementation of Conway's Game of Life that meets all specified requirements.

## 1. Core Architecture Strategy
To ensure stability and correctness while still offering "superspeed", I will implement a **Hybrid Engine**:
*   **Naive/Sparse Engine (Primary for Animation)**:
    *   Uses a `Set<string>` or `Map<string, int>` (key="x,y") to store live cells.
    *   Optimized for infinite grids by only processing live cells and their neighbors.
    *   Used for standard playback (1 gen/frame) and small jumps ($N \le 10$).
    *   This guarantees the "Start/Pause" and drawing interactions work perfectly without complex quadtree bugs.
*   **Hashlife Engine (Secondary for Large Jumps)**:
    *   I will include a simplified but correct Hashlife implementation (Quadtree + Memoization).
    *   It will be used specifically for the "Jump $2^N$" button when $N > 10$.
    *   I will implement `construct`, `step`, and a `fromSparse`/`toSparse` bridge to convert between the Set-based state and the Quadtree state.
    *   If the jump size is too massive or complex, I will gracefully fallback or limit $N$ to avoid browser hangs, but I'll aim for a working Hashlife implementation for reasonably large $N$ (e.g., up to 64 if possible, or limit to ~20-30 for safety).

## 2. Implementation Steps

### Step 1: Global Setup & State Management
*   Define `CONFIG`, `STATE`, `PATTERNS` at the top level to avoid `ReferenceError`.
*   Ensure `canvas`, `ctx`, `container` are correctly retrieved and initialized.
*   Implement `resizeCanvas` properly handling `devicePixelRatio`.

### Step 2: Sparse Grid Engine (The "Safe" Foundation)
*   **Data Structure**: `Set<string>` (format "x,y").
*   **`stepNaive()`**:
    *   Count neighbors using a `Map`.
    *   Apply B3/S23 rules.
    *   Update the Set.
    *   Update `STATE.generation` and `STATE.population`.
*   **`render()`**:
    *   Clear canvas.
    *   Apply camera transform (pan/zoom).
    *   Iterate the Set, cull off-screen cells, and draw visible ones.

### Step 3: Interaction Layer
*   **Pointer Events**:
    *   Implement robust Pan (Right-click) and Zoom (Wheel) logic modifying `STATE.camera`.
    *   Implement Draw (Left-click) and Erase (Shift+Left) modifying the Set.
    *   Fix coordinate mapping: Screen (px) -> World (grid) transformation.

### Step 4: Hashlife Integration (The "Advanced" Feature)
*   Define `Node` class with `nw, ne, sw, se`, `level`, `id`.
*   Implement `canonicalize(node)` for hash consing.
*   Implement `nextGen(node)` with memoization.
*   **Bridge**:
    *   `universeToQuadtree()`: Convert current sparse Set to a Quadtree.
    *   `quadtreeToUniverse()`: Convert Quadtree back to sparse Set (for rendering and subsequent naive steps).
*   **Jump Logic**:
    *   If $N$ is small, loop `stepNaive`.
    *   If $N$ is large, convert to Quadtree -> advance by $2^N$ (or nearest power supported by root depth) -> convert back.

### Step 5: UI & Controls
*   Bind all buttons (Start, Jump, Reset).
*   Pattern Injection: Add `gosper`, `galaxy`, etc., directly into the Set.
*   Update stats (Generation, Population).

### Step 6: Verification & Cleanup
*   Self-correction on `node.center()`: Hashlife nodes usually return a smaller inner node. I will ensure the logic accounts for spatial shifting or use a padding approach to keep the center consistent.
*   Ensure no `ReferenceError` remains.
*   Add clear comments dividing Naive vs Hashlife logic.

## 3. Deliverable
A single, complete `index.html` file containing the CSS, HTML, and the new robust JavaScript implementation.
